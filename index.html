<!DOCTYPE html>
<html lang="zh-CN">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>Key-Data-Management</title>
    <style>
      :root {
        font-family: "Inter", "PingFang SC", system-ui, -apple-system, BlinkMacSystemFont, "Segoe UI", sans-serif;
        color: #f8fafc;
        background-color: #020617;
      }
      * {
        box-sizing: border-box;
      }
      body {
        margin: 0;
        padding: 24px;
        display: flex;
        justify-content: center;
        background: radial-gradient(circle at top, rgba(37, 99, 235, 0.15), transparent 60%) #020617;
      }
      main {
        width: min(960px, 100%);
        background: #0f172a;
        border-radius: 16px;
        padding: 32px;
        box-shadow: 0 30px 80px rgba(2, 8, 23, 0.85);
      }
      header {
        margin-bottom: 24px;
      }
      h1 {
        margin: 0 0 8px;
        font-size: 1.75rem;
      }
      p {
        margin: 0;
        color: #cbd5f5;
      }
      .status {
        margin-top: 16px;
        font-size: 0.95rem;
        color: #60a5fa;
      }
      table {
        width: 100%;
        border-collapse: collapse;
        border-spacing: 0;
        font-size: 0.95rem;
      }
      thead {
        position: sticky;
        top: 0;
        background: rgba(30, 41, 59, 0.85);
        z-index: 1;
      }
      th,
      td {
        padding: 12px 14px;
        border-bottom: 1px solid rgba(99, 102, 241, 0.35);
        text-align: left;
        vertical-align: top;
      }
      th {
        font-weight: 600;
        color: #e2e8f0;
        letter-spacing: 0.02em;
      }
      tbody tr:nth-child(odd) {
        background-color: rgba(15, 23, 42, 0.7);
      }
      tbody tr:hover {
        background-color: rgba(37, 99, 235, 0.25);
      }
      a {
        color: #93c5fd;
        text-decoration: none;
      }
      a:hover {
        text-decoration: underline;
      }
      .scroll-wrap {
        overflow-x: auto;
        border-radius: 12px;
      }
      .filters {
        margin-top: 20px;
        display: flex;
        flex-wrap: wrap;
        gap: 16px;
      }
      .filter-field {
        display: flex;
        flex-direction: column;
        gap: 6px;
        min-width: 180px;
      }
      .filter-field span {
        font-size: 0.85rem;
        color: #475569;
      }
      .chip-group {
        display: flex;
        flex-wrap: wrap;
        gap: 8px;
      }
      .chip {
        border: 1px solid rgba(148, 163, 184, 0.6);
        background: transparent;
        color: #e2e8f0;
        padding: 6px 14px;
        border-radius: 999px;
        font-size: 14px;
        line-height: 17px;
        width: 75px;
        height: 34px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .chip:hover {
        border-color: #93c5fd;
        color: #93c5fd;
      }
      .chip--active {
        background: #1d4ed8;
        border-color: #1d4ed8;
        color: #fff;
        box-shadow: 0 6px 16px rgba(37, 99, 235, 0.4);
      }
      input[type="number"],
      select {
        border: 1px solid rgba(148, 163, 184, 0.6);
        border-radius: 10px;
        padding: 8px 12px;
        font-size: 0.95rem;
        background: #1f2937;
        color: #e2e8f0;
      }
      .tab-bar {
        display: flex;
        gap: 12px;
        margin-bottom: 20px;
      }
      .tab-button {
        border: 1px solid transparent;
        background: rgba(255, 255, 255, 0.05);
        color: #cbd5f5;
        padding: 10px 18px;
        border-radius: 999px;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .tab-button--active {
        background: #2563eb;
        border-color: #93c5fd;
        color: #fff;
        box-shadow: 0 10px 25px rgba(37, 99, 235, 0.3);
      }
      .tab-panel {
        display: none;
      }
      .tab-panel--active {
        display: block;
      }
      .metric-grid {
        margin: 12px 0 6px;
      }
      .metric-card {
        background: linear-gradient(135deg, rgba(37, 99, 235, 0.16), rgba(16, 185, 129, 0.12));
        border: 1px solid rgba(148, 163, 184, 0.25);
        border-radius: 12px;
        padding: 14px 16px;
        color: #e2e8f0;
        box-shadow: 0 10px 30px rgba(15, 23, 42, 0.45);
      }
      .metric-label {
        font-size: 1rem;
        color: #cbd5f5;
        margin-bottom: 8px;
        font-weight: 600;
      }
      .metric-row {
        display: flex;
        align-items: baseline;
        justify-content: space-between;
        padding: 6px 0;
        border-bottom: 1px dashed rgba(148, 163, 184, 0.2);
        gap: 10px;
      }
      .metric-row:last-child {
        border-bottom: none;
      }
      .metric-value {
        font-size: 1.25rem;
        font-weight: 700;
      }
      .metric-delta {
        font-size: 0.95rem;
        color: #a5b4fc;
      }
      .metric-delta.positive {
        color: #34d399;
      }
      .metric-delta.negative {
        color: #f87171;
      }
      .plan-block {
        margin: 12px 0 20px;
        padding: 16px 18px;
        border-radius: 12px;
        background: rgba(99, 102, 241, 0.08);
        border: 1px solid rgba(148, 163, 184, 0.25);
        color: #e2e8f0;
      }
      .plan-title {
        margin: 0 0 8px;
        font-weight: 700;
        font-size: 1.05rem;
      }
      .plan-section {
        margin: 6px 0;
      }
      .plan-section strong {
        color: #a5b4fc;
      }
      .plan-list {
        margin: 4px 0 0 14px;
        color: #cbd5f5;
        padding: 0;
        list-style-type: disc;
      }
      @media (max-width: 640px) {
        main {
          padding: 20px;
        }
        table {
          font-size: 0.85rem;
        }
      }
    </style>
  </head>
  <body>
    <main>
      <header style="margin-bottom: 16px;">
        <h1>Key-Data-Management</h1>
      </header>
      <div class="tab-bar">
        <button class="tab-button tab-button--active" data-tab="health">健康</button>
        <button class="tab-button" data-tab="entertainment">娱乐</button>
        <button class="tab-button" data-tab="knowledge">知识库</button>
      </div>
      <section class="tab-panel tab-panel--active" id="tab-health">
        <div id="health-status" class="status">正在加载健康数据...</div>
        <div class="plan-block">
          <p class="plan-title" style="margin: 0 0 6px;">健康 · 迭代计划</p>
          <div class="plan-section">
            <ul class="plan-list">
              <li>待破解：例行化获取苹果健康方法</li>
              <li>待接入：苹果健康其他指标、分部位健身频率、运动状态数据、动态血糖仪数据</li>
              <li>待规划：可视化形态更简洁，有动作指导 —— 后续尝试大模型 API</li>
            </ul>
          </div>
        </div>
        <div class="metric-grid">
          <div class="metric-card">
            <div class="metric-label">睡眠概览（7日滚动）</div>
            <div class="metric-row">
              <span>近7天均时长</span>
              <span class="metric-value" id="metric-avg7">--</span>
            </div>
            <div class="metric-row">
              <span>周环比</span>
              <span class="metric-value">
                <span id="metric-wow">--</span>
                <span class="metric-delta" id="metric-wow-detail" style="margin-left: 8px;">—</span>
              </span>
            </div>
            <div class="metric-row">
              <span>月环比</span>
              <span class="metric-value">
                <span id="metric-mom">--</span>
                <span class="metric-delta" id="metric-mom-detail" style="margin-left: 8px;">—</span>
              </span>
            </div>
            <div class="metric-row" style="padding-top: 2px;">
              <span>说明</span>
              <span class="metric-delta" id="metric-avg7-detail">—</span>
            </div>
          </div>
        </div>
        <div class="scroll-wrap" style="margin-top: 12px;">
          <div id="health-charts" style="display: grid; gap: 18px;">
            <div style="display: grid; gap: 10px;">
              <h3 style="margin: 0;">近三个月睡眠时长（7日均值）</h3>
              <img src="health/sleep_weekly.png" alt="近三个月睡眠趋势" style="max-width: 100%; border-radius: 12px;" />
              <h3 style="margin: 0;">体重（滑动7日均值）</h3>
              <img src="health/weight_trend.png" alt="体重趋势（7日均值）" style="max-width: 100%; border-radius: 12px;" />
            </div>
          </div>
        </div>
      </section>
      <section class="tab-panel" id="tab-entertainment">
      <div class="plan-block">
        <p class="plan-title" style="margin: 0 0 6px;">娱乐 · 迭代计划</p>
        <div class="plan-section">
          <ul class="plan-list">
            <li>接入：王者荣耀自动化战绩分析</li>
            <li>接入：原神自动化任务完成情况</li>
          </ul>
        </div>
      </div>
      <header>
        <p>更新时间：<span id="update-time" style="margin-left: 8px; font-size: 0.9rem;"></span></p>
        <div class="status" id="status">正在加载数据...</div>
        <div class="filters">
          <div class="filter-field">
            <span>视频类型</span>
            <div class="chip-group" id="category-group"></div>
          </div>
          <label class="filter-field">
            <span>单作者视频条数</span>
            <select id="limit-input"></select>
          </label>
        </div>
      </header>
      <div class="scroll-wrap">
        <table>
          <thead>
            <tr id="table-head"></tr>
          </thead>
          <tbody id="table-body"></tbody>
        </table>
      </div>
      </section>
      <section class="tab-panel" id="tab-knowledge">
        <div class="plan-block">
          <p class="plan-title" style="margin: 0 0 6px;">知识库 · 迭代计划</p>
          <div class="plan-section">
            <ul class="plan-list">
              <li>分析中：微信读书笔记接口</li>
              <li>待规划：大模型理解并总结笔记、播客、优质视频</li>
            </ul>
          </div>
        </div>
        <p>知识库敬请期待。</p>
      </section>
    </main>
    <script>
      const statusEl = document.getElementById("status");
      const updateTimeEl = document.getElementById("update-time");
      const headRow = document.getElementById("table-head");
      const bodyEl = document.getElementById("table-body");
      const categoryGroup = document.getElementById("category-group");
      const limitInput = document.getElementById("limit-input");
      const tabButtons = document.querySelectorAll(".tab-button");
      const tabPanels = document.querySelectorAll(".tab-panel");
      const healthStatus = document.getElementById("health-status");
      const metricAvg7 = document.getElementById("metric-avg7");
      const metricAvg7Detail = document.getElementById("metric-avg7-detail");
      const metricWow = document.getElementById("metric-wow");
      const metricWowDetail = document.getElementById("metric-wow-detail");
      const metricMom = document.getElementById("metric-mom");
      const metricMomDetail = document.getElementById("metric-mom-detail");

      const CATEGORY_OPTIONS = ["全部", "超优质", "历史区", "创意区", "运动区", "游戏区", "影视综", "数分"];
      const DEFAULT_CATEGORY = "超优质";
      const DEFAULT_LIMIT = 1;
      const MAX_LIMIT = 10;
      const CSV_SOURCES = [
        { url: "video/video_ls.csv", label: "Local" },
        { url: "https://raw.githubusercontent.com/xujl1999/Key-Data-Management/main/video/video_ls.csv", label: "GitHub Raw" },
      ];
      const HEALTH_SOURCES = [
        { url: "health/sleep_daily.csv", label: "Local" },
        { url: "https://raw.githubusercontent.com/xujl1999/Key-Data-Management/main/health/sleep_daily.csv", label: "GitHub Raw" },
      ];

      let records = [];
      let activeCategory = CATEGORY_OPTIONS.includes(DEFAULT_CATEGORY) ? DEFAULT_CATEGORY : CATEGORY_OPTIONS[0];

      const fallbackHeader = (text, index) => {
        if (text && text.trim()) return text.trim();
        return index === 0 ? "id" : `col_${index}`;
      };

      const parseCSV = (text) => {
        const rows = [];
        let current = "";
        let row = [];
        let inQuotes = false;

        for (let i = 0; i < text.length; i++) {
          const char = text[i];
          const next = text[i + 1];

          if (char === "\r" && next === "\n" && !inQuotes) {
            continue;
          }

          if (char === "\n" && !inQuotes) {
            row.push(current);
            rows.push(row);
            row = [];
            current = "";
            continue;
          }

          if (char === '"') {
            if (inQuotes && next === '"') {
              current += '"';
              i++;
            } else {
              inQuotes = !inQuotes;
            }
            continue;
          }

          if (char === "," && !inQuotes) {
            row.push(current);
            current = "";
            continue;
          }

          current += char;
        }

        if (current.length > 0 || row.length) {
          row.push(current);
          rows.push(row);
        }

        return rows.filter((cells) => cells.some((cell) => cell.trim().length));
      };

      const normalizeKey = (text) => text.trim().toLowerCase();

      const parseDate = (text) => {
        const d = new Date(text);
        return Number.isNaN(d.getTime()) ? null : d;
      };

      const createCell = (tag, text, linkHref = "") => {
        const cell = document.createElement(tag);
        if (linkHref && text) {
          const link = document.createElement("a");
          link.href = linkHref;
          link.target = "_blank";
          link.rel = "noopener";
          link.textContent = text;
          cell.appendChild(link);
        } else {
          cell.textContent = text || "";
        }
        return cell;
      };

      const parsePublishDate = (text) => {
        if (!text) return 0;
        const now = new Date();
        const cleaned = text.trim();
        if (!cleaned) return 0;

        const normalized = cleaned.replace(/\./g, "-");
        const direct = Date.parse(normalized);
        if (!Number.isNaN(direct)) {
          return direct;
        }

        const mmddPattern = /^(\d{1,2})-(\d{1,2})(?:\s+(\d{1,2}):(\d{2}))?$/;
        const mmddMatch = cleaned.match(mmddPattern);
        if (mmddMatch) {
          const year = now.getFullYear();
          const month = parseInt(mmddMatch[1], 10) - 1;
          const day = parseInt(mmddMatch[2], 10);
          const hour = mmddMatch[3] ? parseInt(mmddMatch[3], 10) : 0;
          const minute = mmddMatch[4] ? parseInt(mmddMatch[4], 10) : 0;
          const guessed = new Date(year, month, day, hour, minute);
          if (guessed > now) {
            guessed.setFullYear(year - 1);
          }
          return guessed.getTime();
        }

        const relHour = cleaned.match(/^(\d+)\s*小时前$/);
        if (relHour) {
          const diff = parseInt(relHour[1], 10);
          const d = new Date(now);
          d.setHours(d.getHours() - diff);
          return d.getTime();
        }

        const relMinute = cleaned.match(/^(\d+)\s*分钟前$/);
        if (relMinute) {
          const diff = parseInt(relMinute[1], 10);
          const d = new Date(now);
          d.setMinutes(d.getMinutes() - diff);
          return d.getTime();
        }

        const yesterdayMatch = cleaned.match(/^昨天(?:\s+(\d{1,2}):(\d{2}))?$/);
        if (yesterdayMatch) {
          const d = new Date(now);
          d.setDate(d.getDate() - 1);
          const hour = yesterdayMatch[1] ? parseInt(yesterdayMatch[1], 10) : 0;
          const minute = yesterdayMatch[2] ? parseInt(yesterdayMatch[2], 10) : 0;
          d.setHours(hour, minute, 0, 0);
          return d.getTime();
        }

        const todayTime = cleaned.match(/^(\d{1,2}):(\d{2})$/);
        if (todayTime) {
          const d = new Date(now);
          d.setHours(parseInt(todayTime[1], 10), parseInt(todayTime[2], 10), 0, 0);
          return d.getTime();
        }

        if (cleaned === "刚刚") {
          return now.getTime();
        }

        return 0;
      };

      const ensureLimitValue = () => {
        let value = parseInt(limitInput.value, 10);
        if (Number.isNaN(value) || value < 1) {
          value = DEFAULT_LIMIT;
        }
        value = Math.min(value, MAX_LIMIT);
        limitInput.value = value;
        return value;
      };

      const initLimitSelect = () => {
        limitInput.innerHTML = "";
        for (let i = 1; i <= MAX_LIMIT; i++) {
          const option = document.createElement("option");
          option.value = i;
          option.textContent = i;
          if (i === DEFAULT_LIMIT) {
            option.selected = true;
          }
          limitInput.appendChild(option);
        }
      };

      const switchTab = (target) => {
        tabButtons.forEach((button) => {
          button.classList.toggle("tab-button--active", button.dataset.tab === target);
        });
        tabPanels.forEach((panel) => {
          panel.classList.toggle("tab-panel--active", panel.id === `tab-${target}`);
        });
      };

      const renderLineChart = (container, data, options = {}) => {
        container.innerHTML = "";
        if (!data.length) {
          container.textContent = "暂无数据";
          return;
        }
        const width = options.width || 800;
        const height = options.height || 280;
        const padding = 30;

        const xs = data.map((_, idx) => idx);
        const ys = data.map((d) => d.value);
        const minY = Math.min(...ys, 0);
        const maxY = Math.max(...ys, 1);
        const yRange = maxY - minY || 1;

        const scaleX = (x) =>
          padding + (x / Math.max(xs.length - 1, 1)) * (width - padding * 2);
        const scaleY = (y) =>
          height - padding - ((y - minY) / yRange) * (height - padding * 2);

        const points = data.map((d, idx) => `${scaleX(idx)},${scaleY(d.value)}`).join(" ");

        const svg = document.createElementNS("http://www.w3.org/2000/svg", "svg");
        svg.setAttribute("viewBox", `0 0 ${width} ${height}`);
        svg.setAttribute("width", "100%");
        svg.setAttribute("height", "320");

        // Axes (minimal)
        const axis = document.createElementNS("http://www.w3.org/2000/svg", "line");
        axis.setAttribute("x1", padding);
        axis.setAttribute("y1", scaleY(minY));
        axis.setAttribute("x2", width - padding);
        axis.setAttribute("y2", scaleY(minY));
        axis.setAttribute("stroke", "rgba(148,163,184,0.4)");
        axis.setAttribute("stroke-width", "1");
        svg.appendChild(axis);

        const polyline = document.createElementNS("http://www.w3.org/2000/svg", "polyline");
        polyline.setAttribute("points", points);
        polyline.setAttribute("fill", "none");
        polyline.setAttribute("stroke", options.color || "#60a5fa");
        polyline.setAttribute("stroke-width", "2");
        svg.appendChild(polyline);

        // Labels (first/last)
        const addLabel = (text, x, y) => {
          const t = document.createElementNS("http://www.w3.org/2000/svg", "text");
          t.setAttribute("x", x);
          t.setAttribute("y", y);
          t.setAttribute("fill", "#cbd5f5");
          t.setAttribute("font-size", "12");
          t.textContent = text;
          svg.appendChild(t);
        };

        if (data.length) {
          addLabel(data[0].label, scaleX(0), height - padding + 14);
          addLabel(data[data.length - 1].label, scaleX(data.length - 1) - 20, height - padding + 14);
          addLabel(maxY.toFixed(1), padding, scaleY(maxY) - 6);
          addLabel(minY.toFixed(1), padding, scaleY(minY) + 14);
        }

        container.appendChild(svg);
      };

      const renderCategoryChips = () => {
        categoryGroup.innerHTML = "";
        CATEGORY_OPTIONS.forEach((label) => {
          const chip = document.createElement("button");
          chip.type = "button";
          chip.className = `chip${label === activeCategory ? " chip--active" : ""}`;
          chip.textContent = label;
          chip.addEventListener("click", () => {
            if (activeCategory === label) return;
            activeCategory = label;
            renderCategoryChips();
            applyFilters();
          });
          categoryGroup.appendChild(chip);
        });
      };

      const buildRecords = (rows) => {
        if (!rows.length) return [];
        const headers = rows[0].map(fallbackHeader).map(normalizeKey);
        return rows.slice(1).map((row) => {
          const record = {};
          headers.forEach((key, idx) => {
            record[key] = (row[idx] || "").trim();
          });
          record._timestamp = parsePublishDate(record.publish_date || record["publish_date"]);
          return record;
        });
      };

      const renderHeader = () => {
        headRow.innerHTML = "";
        ["作者", "视频发布时间", "视频名称"].forEach((text) => {
          headRow.appendChild(createCell("th", text));
        });
      };

      const renderBody = (rows) => {
        bodyEl.innerHTML = "";
        if (!rows.length) {
          const tr = document.createElement("tr");
          const cell = document.createElement("td");
          cell.colSpan = 3;
          cell.textContent = "暂无数据";
          tr.appendChild(cell);
          bodyEl.appendChild(tr);
          return;
        }

        rows.forEach((item) => {
          const tr = document.createElement("tr");
          tr.appendChild(createCell("td", item.author || "-"));
          tr.appendChild(createCell("td", item.publish_date || "-"));
          tr.appendChild(createCell("td", item.title || "", item.url || ""));
          bodyEl.appendChild(tr);
        });
      };

      const applyFilters = () => {
        if (!records.length) {
          renderBody([]);
          statusEl.textContent = "暂无数据";
          return;
        }

        const limit = ensureLimitValue();
        const authorCounts = new Map();
        const authorSet = new Set();
        const rows = [];

        records.forEach((record) => {
          const category = record.category || record["category"] || "";
          if (!record.author || !record.title) return;
          if (activeCategory !== "全部" && category !== activeCategory) return;

          const used = authorCounts.get(record.author) || 0;
          if (used >= limit) return;

          authorCounts.set(record.author, used + 1);
          authorSet.add(record.author);
          rows.push(record);
        });

        rows.sort((a, b) => (b._timestamp || 0) - (a._timestamp || 0));

        renderBody(rows);

        if (rows.length) {
          statusEl.textContent = `筛选：${activeCategory} · 作者 ${authorSet.size} 位，共 ${rows.length} 条（每位最多 ${limit} 条）`;
        } else {
          statusEl.textContent = "暂无匹配数据";
        }
      };

      limitInput.addEventListener("change", () => {
        ensureLimitValue();
        applyFilters();
      });

      tabButtons.forEach((button) => {
        button.addEventListener("click", () => switchTab(button.dataset.tab));
      });

      const formatUpdateTime = (date) => {
        const year = date.getFullYear();
        const month = String(date.getMonth() + 1).padStart(2, "0");
        const day = String(date.getDate()).padStart(2, "0");
        const hours = String(date.getHours()).padStart(2, "0");
        const minutes = String(date.getMinutes()).padStart(2, "0");
        return ` ${year}-${month}-${day} ${hours}:${minutes}`;
      };

      const isSameOrigin = (url) => {
        try {
          const absolute = new URL(url, window.location.href);
          return absolute.origin === window.location.origin;
        } catch (error) {
          console.warn("Invalid URL for origin check", url, error);
          return false;
        }
      };

      const resolveLastModified = async (response, url) => {
        const headerValue = response.headers.get("Last-Modified");
        if (headerValue) {
          const parsed = new Date(headerValue);
          if (!Number.isNaN(parsed.getTime())) {
            return parsed;
          }
        }
        if (!isSameOrigin(url)) {
          return null;
        }
        try {
          const headResp = await fetch(url, { method: "HEAD", cache: "no-store" });
          if (headResp.ok) {
            const headValue = headResp.headers.get("Last-Modified");
            if (headValue) {
              const fallback = new Date(headValue);
              if (!Number.isNaN(fallback.getTime())) {
                return fallback;
              }
            }
          }
        } catch (error) {
          console.warn("HEAD request failed", error);
        }
        return null;
      };

      const fetchHealthSource = async () => {
        const errors = [];
        for (const source of HEALTH_SOURCES) {
          try {
            const response = await fetch(source.url, { cache: "no-store" });
            if (!response.ok) throw new Error(`HTTP ${response.status}`);
            const text = await response.text();
            return { text, sourceLabel: source.label };
          } catch (error) {
            errors.push(`${source.label}: ${error.message}`);
          }
        }
        throw new Error(errors.join(" | "));
      };

      const parseHealth = (text) => {
        const rows = parseCSV(text);
        if (!rows.length) return [];
        const headers = rows[0].map((h) => h.trim().toLowerCase());
        const idxDate = headers.indexOf("date");
        const idxHours = headers.indexOf("sleep_hours");
        if (idxDate === -1 || idxHours === -1) return [];
        return rows
          .slice(1)
          .map((cells) => {
            const d = parseDate(cells[idxDate]);
            const h = parseFloat(cells[idxHours]);
            if (!d || Number.isNaN(h)) return null;
            return { date: d, hours: h };
          })
          .filter(Boolean)
          .sort((a, b) => a.date - b.date);
      };

      const computeRolling = (items, window = 7) => {
        const result = [];
        const queue = [];
        let sum = 0;
        items.forEach((item) => {
          queue.push(item.hours);
          sum += item.hours;
          if (queue.length > window) {
            sum -= queue.shift();
          }
          result.push({ date: item.date, ma: sum / queue.length });
        });
        return result;
      };

      const avgWindow = (series, count, offset = 0) => {
        if (series.length < count + offset) return null;
        const slice = series.slice(series.length - count - offset, series.length - offset);
        const total = slice.reduce((acc, cur) => acc + cur.ma, 0);
        return total / slice.length;
      };

      const formatDelta = (current, previous) => {
        if (current === null || previous === null || previous === 0) return { text: "—", cls: "" };
        const delta = ((current - previous) / previous) * 100;
        const cls = delta > 0 ? "positive" : delta < 0 ? "negative" : "";
        const sign = delta > 0 ? "+" : "";
        return { text: `${sign}${delta.toFixed(1)}%`, cls };
      };

      const loadHealth = async () => {
        healthStatus.textContent = "正在加载健康数据...";
        try {
          const { text, sourceLabel } = await fetchHealthSource();
          const items = parseHealth(text);
          if (!items.length) {
            healthStatus.textContent = "健康数据为空";
            return;
          }
          const rolling = computeRolling(items, 7);
          const lastDate = items[items.length - 1].date;
          const last7 = avgWindow(rolling, 7, 0);
          const prev7 = avgWindow(rolling, 7, 7);
          const last30 = avgWindow(rolling, 30, 0);
          const prev30 = avgWindow(rolling, 30, 30);

          const fmtHours = (val) => (val === null ? "--" : `${val.toFixed(2)} 小时`);
          metricAvg7.textContent = fmtHours(last7);
          const wow = formatDelta(last7, prev7);
          metricWow.textContent = wow.text === "—" ? "--" : wow.text;
          metricWowDetail.textContent = prev7 === null ? "样本不足" : "相较前7天";
          metricWowDetail.className = `metric-delta ${wow.cls}`;

          const mom = formatDelta(last30, prev30);
          metricMom.textContent = mom.text === "—" ? "--" : mom.text;
          metricMomDetail.textContent = prev30 === null ? "样本不足" : "相较前30天";
          metricMomDetail.className = `metric-delta ${mom.cls}`;

          metricAvg7Detail.textContent = last7 === null ? "样本不足" : `截止 ${formatUpdateTime(lastDate).trim()}`;

          const totalDays = items.length;
          healthStatus.textContent = `数据截止 ${formatUpdateTime(lastDate).trim()} · 共 ${totalDays} 天 · 来源：${sourceLabel}`;
        } catch (error) {
          console.error(error);
          healthStatus.textContent = "健康数据加载失败";
        }
      };

      const fetchCSVSource = async () => {
        const errors = [];
        for (const source of CSV_SOURCES) {
          try {
            const response = await fetch(source.url, { cache: "no-store" });
            if (!response.ok) {
              throw new Error(`HTTP ${response.status}`);
            }
            const text = await response.text();
            const lastModified = await resolveLastModified(response, source.url);
            return { text, lastModified, sourceLabel: source.label };
          } catch (error) {
            errors.push(`${source.label}: ${error.message}`);
          }
        }
        throw new Error(errors.join(" | "));
      };

      const loadCSV = async () => {
        statusEl.textContent = "正在加载数据...";
        updateTimeEl.textContent = " 正在获取...";
        try {
          const { text, lastModified, sourceLabel } = await fetchCSVSource();
          if (lastModified) {
            updateTimeEl.textContent = formatUpdateTime(lastModified);
            updateTimeEl.title = `${lastModified.toString()} · 来源：${sourceLabel}`;
          } else {
            updateTimeEl.textContent = ` 无可用数据（来源：${sourceLabel})`;
            updateTimeEl.removeAttribute("title");
          }
          const rows = parseCSV(text);
          if (!rows.length) {
            statusEl.textContent = "CSV 文件为空";
            records = [];
            renderBody([]);
            return;
          }
          records = buildRecords(rows);
          applyFilters();
        } catch (error) {
          console.error(error);
          statusEl.textContent = "加载失败，请确认 CSV 文件路径正确";
          records = [];
          renderBody([]);
        }
      };

      renderCategoryChips();
      initLimitSelect();
      ensureLimitValue();
      renderHeader();
      renderBody([]);
      loadHealth();
      loadCSV();
    </script>
  </body>
</html>
